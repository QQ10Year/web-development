C语言中由于指针的灵活性，导致指针能代替数组使用，或者混合使用，这些导致了许多指针和数组的迷惑，因此，刻意再次深入探究了指针和数组这玩意儿，其他类型的数组比较简单，容易混淆的是字符数组和字符指针这两个。。。下面就开始剖析一下这两位的恩怨情仇。。。
　１　数组的本质

　　　数组是多个元素的集合，在内存中分布在地址相连的单元中，所以可以通过其下标访问不同单元的元素。。

　２　指针。

　　　指针也是一种变量，只不过它的内存单元中保存的是一个标识其他位置的地址。。由于地址也是整数，在３２位平台下，指针默认为３２位。。

　３　指针的指向？

　　　指向的直接意思就是指针变量所保存的其他的地址单元中所存放的数据类型。

　　　int  * p ;//p 变量保存的地址所在内存单元中的数据类型为整型

           float *q;// ........................................浮点型

           不论指向的数据类型为那种，指针变量其本身永远为整型，因为它保存的地址。

    4  字符数组。。。

        字面意思是数组，数组中的元素是字符。。确实，这就是它的本质意义。

         char  str[10]; 

         定义了一个有十个元素的数组，元素类型为字符。

         C语言中定义一个变量时可以初始化。

         char  str[10] = {"hello world"};

         当编译器遇到这句时，会把str数组中从第一个元素把hello world\0 逐个填入。。

         由于C语言中没有真正的字符串类型，可以通过字符数组表示字符串，因为它的元素地址是连续的，这就足够了。

         C语言中规定数组代表数组所在内存位置的首地址，也是 str[0]的地址，即str = &str[0];

         而printf("%s",str); 为什么用首地址就可以输出字符串。。

          因为还有一个关键，在C语言中字符串常量的本质表示其实是一个地址，这是许多初学者比较难理解的问题。。。

          举例：

          char  *s ;

          s = "China";

          为什么可以把一个字符串赋给一个指针变量。。

          这不是类型不一致吗？？？

          这就是上面提到的关键 。。

          C语言中编译器会给字符串常量分配地址，如果 "China", 存储在内存中的 0x3000 0x3001 0x3002 0x3003 0x3004 0x3005 .

          s = "China" ，意识是什么，对了，地址。

          其实真正的意义是 s ="China" = 0x3000;

          看清楚了吧 ，你把China 看作是字符串，但是编译器把它看作是地址 0x3000，即字符串常量的本质表现是代表它的第一个字符的地址。。。。。。。。。。

          s = 0x3000

          这样写似乎更符合直观的意思。。。

          搞清楚这个问题。。

          那么 %s ，它的原理其实也是通过字符串首地址输出字符串，printf("%s ", s);   传给它的其实是s所保存的字符串的地址。。。
